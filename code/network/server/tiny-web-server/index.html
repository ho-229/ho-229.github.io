

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/ho-229.jpg">
  <link rel="icon" href="/image/ho-229.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ho 229">
  <meta name="keywords" content="">
  
    <meta name="description" content="鸽了两年的 blog，我终于回来辣（ 这篇 blog 是关于自己胡的一个玩具 HTTP Server。做这个项目的想法来源于 CS:APP 的 TINY Web 服务器实践。（当时感觉挺简单的，现在回头一看全是坑qwq）">
<meta property="og:type" content="article">
<meta property="og:title" content="关于一个 Tiny Web Server 的实现">
<meta property="og:url" content="https://ho-229.github.io/code/network/server/tiny-web-server/index.html">
<meta property="og:site_name" content="Ho 229&#39;s blogs">
<meta property="og:description" content="鸽了两年的 blog，我终于回来辣（ 这篇 blog 是关于自己胡的一个玩具 HTTP Server。做这个项目的想法来源于 CS:APP 的 TINY Web 服务器实践。（当时感觉挺简单的，现在回头一看全是坑qwq）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-29T12:42:16.000Z">
<meta property="article:modified_time" content="2024-06-14T09:36:41.296Z">
<meta property="article:author" content="Ho 229">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="WebServer">
<meta property="article:tag" content="HTTP">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>关于一个 Tiny Web Server 的实现 - Ho 229&#39;s blogs</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ho-229.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ho 229 の Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/post.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.2)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="关于一个 Tiny Web Server 的实现"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-01-29 20:42" pubdate>
          2022年1月29日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          35 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">关于一个 Tiny Web Server 的实现</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年6月14日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>鸽了两年的 blog，我终于回来辣（</p>
<p>这篇 blog 是关于自己胡的一个玩具 HTTP Server。做这个项目的想法来源于 CS:APP 的 TINY Web 服务器实践。（当时感觉挺简单的，现在回头一看全是坑qwq）</p>
<span id="more"></span>

<blockquote>
<p>友情提示：此篇 blog 废话较多。作者不是计算机专业的学生，也不从事计算机方面的工作。为节约您的宝贵时间，请酌情观看。</p>
</blockquote>
<p>项目地址： <a target="_blank" rel="noopener" href="https://github.com/ho-229/Network-Learn">https://github.com/ho-229/Network-Learn</a></p>
<h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><pre><code class=" mermaid">flowchart TB
    main((&quot;main()&quot;)) --Thread 0--&gt; listen[&quot;WebServer::listen()&quot;];

    subgraph exec[&quot;WebServer::exec()&quot;]
        start[&quot;WebServer::start()&quot;]

        subgraph loop0[&quot;EventLoop::exec()&quot;]
            direction LR

            epoll[&quot;Epoll::epoll()&quot;]

            subgraph process[&quot;EventLoop::processQueue()&quot;]
                accept[&quot;AbstractSocket::accept()&quot;]
                services[&quot;AbstractServices::process()&quot;]
            end

            epoll --isListener--&gt; accept
            epoll --clientSocket--&gt; services

            process --&gt; epoll
        end

        subgraph loopN[&quot;EventLoop::exec()&quot;]
            ...
        end
        
        start --Thread 1--&gt; loop0
        start --Thread N--&gt; loopN

        wait[&quot;WebServer::waitForFinished()&quot;]

        loop0 --&gt; wait
        loopN --&gt; wait
    end

    listen --&gt; start

    wait --&gt; e((exit))</code></pre>

<p>先来看看大致的并发模型，其思想是 <code>one loop per thread</code>。在 WebServer::start() 中创建了 N 个工作线程和 EventLoop，然后将 listeners 分发到每一个 EventLoop。在 EventLoop::exec() 中循环调用 Epoll::epoll() 等待请求到达，并调用 AbstractServices::process() 处理 I&#x2F;O 和协议相关的业务。</p>
<p>这种多线程 + <a href="#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8F%8A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%AE%9E%E7%8E%B0">I&#x2F;O 多路复用</a> 的并发模型类似于 Nginx（把进程换成了线程）。每个 EventLoop 之间相互独立，所以工作线程之间没有显式的同步代码，也没有切换进程上下文开销。</p>
<h2 id="Socket-抽象及跨平台实现"><a href="#Socket-抽象及跨平台实现" class="headerlink" title="Socket 抽象及跨平台实现"></a>Socket 抽象及跨平台实现</h2><pre><code class=" mermaid">classDiagram
    direction LR

    class AbstractSocket &#123;
        +read(buf, size)* ssize_t
        +write(buf, size)* ssize_t
        +close()*
        +sslEnable()* bool
        +isValid()* bool
        +sendFile(file, offset, count)* ssize_t

        +listen(hostName, port) bool
        +accpet() Socket

        -AbstractSocket()

        #Socket m_descriptor
        #bool m_isListener
    &#125;

    class TcpSocket &#123;
        +TcpSocket()
    &#125;

    class SslSocket &#123;
        +SslSocket()

        +initializatSsl(certFile, privateKey)$ bool
        +cleanUpSsl()$
        +sslVersion()$ string
        +isSslAvailable()$ bool

        -SSL m_ssl
        -SSL_CTX sslContext$
    &#125;

    AbstractSocket &lt;|-- TcpSocket : implements
    AbstractSocket &lt;|-- SslSocket : implements</code></pre>

<p>AbstractSocket 的两个派生类分别是 TcpSocket 和 SslSocket，分别是 <code>TCP</code> 和 <code>SSL</code> 链接的跨平台实现。</p>
<p>TcpSocket 的构造函数什么也不做，而 SslSocket 的构造函数会调用 SSL_accept() 完成 <code>SSL</code> 握手。</p>
<p>AbstactScoket::read() 和 AbstractSocket::write() 是 <code>RIO</code>（自动处理不足值） 跨平台实现的抽象接口。<br>TcpSocket 在 Linux 上使用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> 和 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>，在 Windows 上使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv">recv()</a> 和 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-send">send()</a>；<br>SslSocket 使用 <a target="_blank" rel="noopener" href="https://www.openssl.org/docs/man1.1.1/man3/SSL_read.html">SSL_read()</a> 和 <a target="_blank" rel="noopener" href="https://www.openssl.org/docs/man1.1.1/man3/SSL_write.html">SSL_write()</a> 实现。需要注意的是某些 API 的 size 和返回值类型是 int，直接传参可能会导致整数溢出 <del>（屑 Windows 和屑 OpenSSL）</del>。</p>
<p>AbstractSocket::sendFile() 是发送文件（Handle 或 file descriptor）的 <code>RIO</code> 抽象接口。TcpSocket::sendFile() 在 Linux 上使用 <a target="_blank" rel="noopener" href="https://linux.die.net/man/2/sendfile64">sendfile64()</a>（sendfile64 和其他 I&#x2F;O 函数一样会返回不足值）；其余平台和 SslSocket 的实现都是 <a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man2/mmap.2.html">mmap</a> + AbstractSocket::write()。这里会有几个问题：</p>
<ol>
<li>为什么要用 sendfile64 呢？因为它 <del>（方便，快）</del> 是 Linux 提供的一个在两个文件描述符之间传递数据的“零拷贝”函数（也是 <code>syscall</code>）。在最新的实现中，它通过设置 <code>DMA</code> 将数据从 <code>kernel buffer</code> 直接传输到协议引擎。</li>
<li>为什么 Linux 上的 SslSocket::sendFile() 不能用 sendfile64 实现呢？因为 sendfile64 不支持对数据进行 <code>SSL</code> 加密。实际上在 OpenSSL 3.0.0+ 的版本中添加了 <a target="_blank" rel="noopener" href="https://beta.openssl.org/docs/manmaster/man3/SSL_sendfile.html">SSL_sendfile()</a> 这个 API，但是 OpenSSL 3 尚未普及且需要 <code>kernel TLS/SSL</code> 支持。</li>
<li>为什么其他的实现要用 mmap + AbstractSocket::write() 而不是 read() + AbstractSocket::write() 呢？主要是因为 mmap 不会改变文件描述符的 seek ，也不会受其影响；其次是 mmap 比 read() 少了一次从 <code>kernel buffer</code> 到 <code>user buffer</code> 的复制。</li>
</ol>
<p>AbstractSocket::listen() 是与协议版本无关的监听函数，具体实现可以参考 CS:APP 第三版 P662 的 open_listenfd。<br>AbstractSocket::accept() 会非阻塞地返回一个连接描述符（如果没有则返回错误码）。需要注意的是 Windows 的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept">accept()</a> 返回的套接字会继承 listener 的（非）阻塞状态而 *nix 的 accept() 则不会。所以在 Linux 下需要调用 <a target="_blank" rel="noopener" href="https://linux.die.net/man/2/accept4">accept4()</a> （Linux 的私货）将返回的连接描述符设置为非阻塞，如果是 Unix 系的话就只能在 accept() 之后再调用 fcntl() 将连接套接字设置为非阻塞。</p>
<h2 id="I-O-多路复用及跨平台实现"><a href="#I-O-多路复用及跨平台实现" class="headerlink" title="I&#x2F;O 多路复用及跨平台实现"></a>I&#x2F;O 多路复用及跨平台实现</h2><p>为什么要使用 I&#x2F;O 多路复用呢，一个线程一个 connection 不香么？（doge<br>如果你的服务器上有 10000 个链接，这就意味着你需要开 10000 个线程（C10K）。<del>众所周知，</del> 大量的线程就意味着大量的线程上下文切换，不仅会浪费大量 CPU 周期，还会浪费内存空间。所以我们需要一个线程能够处理多个 I&#x2F;O，这就是 I&#x2F;O 多路复用。</p>
<p>由于这个项目是跨平台项目，然而各个平台优秀的本地接口又各不相同，于是就有了 Epoll 类用来封装跨平台实现。</p>
<p>类 Epoll 主要负责管理 AbstractSocket 的可读和错误（链接断开）事件。Epoll::insert() 和 Epoll::erase() 分别是将套接字添加&#x2F;移出 Epoll。Epoll::epoll() 负责返回可读套接字和发生错误的套接字。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// /TinyWebServer/src/core/epoll.h</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Epoll</span>
&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Epoll</span><span class="hljs-params">()</span></span>;
    ~<span class="hljs-built_in">Epoll</span>();

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(AbstractSocket *<span class="hljs-type">const</span> socket, <span class="hljs-type">bool</span> exclusive = <span class="hljs-literal">false</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(AbstractSocket *<span class="hljs-type">const</span> socket)</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">epoll</span><span class="hljs-params">(std::vector&lt;AbstractSocket *&gt; &amp;events,</span></span>
<span class="hljs-params"><span class="hljs-function">               std::vector&lt;AbstractSocket *&gt; &amp;errorEvents)</span></span>;
    <span class="hljs-comment">// snip</span>
&#125;;</code></pre></div>

<h3 id="Windows（WSAPoll）"><a href="#Windows（WSAPoll）" class="headerlink" title="Windows（WSAPoll）"></a>Windows（WSAPoll）</h3><p>由于 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsapoll">WSAPoll</a> 自身并不维护队列，所以我们要自行维护一个 pollfd 线性队列和一个 <code>fd -&gt; AbstractSocket*</code> 的 Map（以便用 fd 能找到 AbstractSocket*），然后在 Epoll::insert 和 Epoll::erase 中操作它们（如果可能被异步访问还要给数据结构加锁），最后在 Epoll::epoll 中调用 WSAPoll()。</p>
<p>用 WSAPoll 实现会导致低效的一个原因是当调用 Epoll::erase 的时候需要遍历 pollfd 队列找到要删除的元素，然后把在它之后的元素向前移动一遍，还有一个原因是 WSAPoll 没有办法避免惊群 ㄟ( ▔, ▔ )ㄏ。</p>
<h3 id="Linux（epoll）"><a href="#Linux（epoll）" class="headerlink" title="Linux（epoll）"></a>Linux（epoll）</h3><p>到了 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> 就简单了许多，因为它会维护一个红黑树。我们只需要把 AbstractSocket* 传给 epoll_event::data::ptr，在 Epoll::insert 和 Epoll::erase 中只需要把 epoll_ctl 封装一下，然后在 Epoll::epoll 中调用 epoll_wait。</p>
<p>接下来就是 epoll 高效的秘密了。epoll 的边缘触发（<code>EPOLLET</code>）可以让一个事件在新的事件到来之前只触发一次，比起水平触发来说就少了许多冗余事件。还有一个是在 Linux 4.5+ 提供的 <code>EPOLLEXCLUSIVE</code>，它能使被监听的套接字只能触发一个 epoll，完美解决了惊群问题。更低版本的 Linux 可以让每个 EventLoop 持有一组 listeners 并设置 <code>SO_REUSEPORT</code> 让它们能监听同一组端口。</p>
<p><a href="#%E5%85%B3%E4%BA%8E-epoll">关于 Epoll 的碎碎念</a></p>
<h3 id="Unix-MacOS-BSD（kqueue）"><a href="#Unix-MacOS-BSD（kqueue）" class="headerlink" title="Unix &#x2F; MacOS &#x2F; BSD（kqueue）"></a>Unix &#x2F; MacOS &#x2F; BSD（kqueue）</h3><p>到了 <a target="_blank" rel="noopener" href="https://man.openbsd.org/kqueue.2">kqueue</a> 事情变得更简单了，因为它只有两个 API！kqueue() 和 kevent()。和 Epoll 一样，kqueue 也会自己维护队列，在 struct kevent 中也同样有存放用户数据结构指针的地方，不同的是 Epoll::insert、Epoll::erase 和 Epoll::epoll 都是 kevent() 的封装。</p>
<p>从接口设计上来说 kqueue 比 epoll 更高效。一次 kqueue 调用不仅可以同时增加&#x2F;删除多个套接字，还能获取活动事件队列，不过要注意的是，更改的事件只能在下次 kqueue 调用才会生效。kqueue 提供了一个 <code>EV_CLEAR</code> 标志用于实现类似于 <code>EPOLLET</code> 的语义，它的行为是当事件被用户捕获时清除其状态。至于惊群问题就比较遗憾了，kqueue 没有提供类似 <code>EPOLLEXCLUSIVE</code> 的标志，而且在 MacOS 11 上用 <code>SO_REUSEPORT</code> 也没办法解决惊群问题。</p>
<p>虽然但是，kqueue 还是提供了强大的 filter，目前为止我们只使用了 kqueue 的一小部分特性。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127148459">深入学习理解 IO 多路复用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dream0130__/article/details/104009426">epoll在多线程中的应用-EPOLLEXCLUSIVE和REUSEPORT(一)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/">Why does one NGINX worker take all the load?</a></li>
</ul>
<h2 id="EventLoop-及-Timer-实现"><a href="#EventLoop-及-Timer-实现" class="headerlink" title="EventLoop 及 Timer 实现"></a>EventLoop 及 Timer 实现</h2><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// /TinyWebServer/src/core/eventloop.cpp</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::exec</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">while</span>(m_runnable &amp;&amp; m_epoll.<span class="hljs-built_in">count</span>())
    &#123;
        m_epoll.<span class="hljs-built_in">epoll</span>(m_queue, m_errorQueue);

        <span class="hljs-keyword">if</span>(!m_queue.<span class="hljs-built_in">empty</span>())
            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">processQueue</span>();

        <span class="hljs-keyword">if</span>(!m_errorQueue.<span class="hljs-built_in">empty</span>())
            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">processErrorQueue</span>();

        <span class="hljs-comment">// Clean up timeout connections</span>
        m_manager.<span class="hljs-built_in">checkout</span>(m_errorQueue);

        <span class="hljs-keyword">if</span>(!m_errorQueue.<span class="hljs-built_in">empty</span>())
            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">processTimeoutQueue</span>();
    &#125;
&#125;</code></pre></div>

<p>进入 EventLoop::exec() 后，先用 Epoll::epoll() 获取可读套接字队列和错误&#x2F;已关闭套接字队列。</p>
<p>在 EventLoop::processQueue() 中会遍历 m_queue（可读套接字队列）。<br>如果 AbstractSocket 为 listener，就会循环调用 AbstractSocket::accept() 获取新的客户端的套接字描述符直到返回 INVALID_SOCKET，如果 listener 的 sslEnable() 为真会创建一个 SslSocket 对象，反之会创建 TcpSocket 对象，然后为它设置一个 timer 并调用 Epoll::insert()，最后触发 ConnectEvent::Accept；<br>如果 AbstractSocket 为客户端套接字，调用 AbstractServices::process() 处理业务。如果业务处理成功就调用 TimerManager::restart()，如果不成功将会调用 Epoll::erase() 和 TimerManager::destroy()，并触发 ConnectEvent::Close，最后释放套接字内存。</p>
<p>在 EventLoop::processErrorQueue() 中会遍历 m_errorQueue（错误&#x2F;已关闭套接字队列），如果 AbstractSocket 为 listener 会发出一个 ExceptionEvent::ListenerError，反之会触发 ConnectEvent::Close 并关闭它们。</p>
<p>处理超时链接会调用 TimerManager::checkout() 获取不活跃套接字队列，然后调用 EventLoop::processTimeoutQueue() 关闭它们，流程和 EventLoop::processErrorQueue() 类似但不需要判断是否为 listener，因为 listener 不会被放进 TimerManager 里。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// /TinyWebServer/src/util/timermanager.h</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> TimeType&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>
&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">const</span> TimeType&amp; timeout, <span class="hljs-type">const</span> T&amp; data)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; <span class="hljs-title">deadline</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> T&amp; <span class="hljs-title">userData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

    <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Timer&lt;T, TimeType&gt; &amp;right) <span class="hljs-type">const</span>;
    <span class="hljs-comment">// snip</span>
&#125;;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerManager</span>
&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> TimerItem = Timer&lt;T, TimeType&gt;;
    <span class="hljs-keyword">using</span> iterator = <span class="hljs-keyword">typename</span> std::list&lt;TimerItem&gt;::iterator;

    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TimerManager</span><span class="hljs-params">()</span> </span>&#123;&#125;

    <span class="hljs-function">iterator <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">const</span> TimeType&amp; timeout, <span class="hljs-type">const</span> T&amp; data)</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">(iterator timerIt)</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">(iterator it)</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkout</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; list)</span></span>;

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

    <span class="hljs-function">T <span class="hljs-title">takeFirst</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// snip</span>
&#125;;</code></pre></div>

<p>在 TimerManager 中会维护一个 Timer 队列（按 deadline 从低到高）。用 std::list 实现的原因是因为它的 insert 和 erase 是常量时间开销且迭代器不会失效，而且它还提供了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/list/splice">std::list::splice()</a> 可以在迭代器不失效的前提下移动位置。</p>
<p>调用 TimerManager::start() 时会根据 timeout 创建一个 Timer 插入到队列中并返回它的迭代器。这个迭代器会被保存在 AbstractSocket 里。当 AbstractSocket 触发错误事件时可以通过 AbstractSocket::timer() 找到它的 timer 并用 TimerManager::destory() 删除它。</p>
<p>TimerManager::restart() 会调用给定 Timer 的 Timer::reset() 重置它的 deadline，并将它在队列中重新排序。</p>
<p>在 TimerManager::checkout() 中会检查队列的第一个 Timer。如果当前时间大于 Timer::deadline() 则视为超时，此时会将 Timer::userData() 加入 list 并 pop。重复上述操作直到第一个 Timer 不再超时或队列为空。</p>
<p>TimerManager::takeFirst() 会返回第一个 Timer 所持有的 userData 并 pop_front。它会在 EventLoop 析构的时候被调用，以释放 AbstractSocket 所占的内存。</p>
<h2 id="HTTP-实现"><a href="#HTTP-实现" class="headerlink" title="HTTP 实现"></a>HTTP 实现</h2><p>在谈 HttpRequest 和 HttpResponse 之前，我们先来聊聊 <code>HTTP header</code> 的存储（因为它俩的实现都要用到）。</p>
<p>众所周知，<code>HTTP header</code> 是不区分大小写的，如果我们想用 Map 来存储 header（name -&gt; value），要么把查询和储存都转成大&#x2F;小写，要么做忽略大小写的匹配。这里我选择了第二种处理方式，因为这种方式没有对原数据和查询数据的修改。但是 STL 中并没有这方面的支持。对于 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/map">std::map</a>，我们需要自定义 Compare；对于 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/unordered_map">std::unordered_map</a>，我们需要自定义 Compare 和 Hasher。</p>
<p>先说 Compare。实际上 std::map 和 std::unordered_map 的 Compare 是不一样的（因为一个是二叉树一个是哈希表），所以 std::map 的 Compare 是比较谁大（或谁小），而 std::unordered_map 的是比较两个值是否相等。虽然 STL 并没有提供忽略大小写比较字符串的 functor，但是在 string.h 中提供了相关函数，也就是说我们只需要做跨平台封装就行了，在 Windows 上是 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strnicmp-wcsnicmp-mbsnicmp-strnicmp-l-wcsnicmp-l-mbsnicmp-l?view=msvc-170">_strnicmp()</a>，在 Linux 上是 <a target="_blank" rel="noopener" href="https://linux.die.net/man/3/strncasecmp">strncasecmp()</a>。细心的你一定会发现用的都是带 size 参数的版本，这是因为带边界检查可以避免很多潜在问题，比如说比较的字符串不是以 \0 结尾…</p>
<p>然后就是 Hasher，这里实现是用 Key 的第一个字母的小写作为哈希值（<del>至于碰撞嘛，能用就行</del>。</p>
<h3 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h3><p>HttpRequest 主要的功能是解析及保存 <code>HTTP</code> 请求。</p>
<p>关于 parser 的细节就不过多介绍了（因为这方面我不在行，而且手写 parser 真的是噩梦），这个 parser 虽然不是用状态机实现的，但是运行起来也近似于状态机。接下来是关于 <code>URI</code> 的转义处理，转义标准可以参考 <code>JavaScript</code> 的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI">decodeURI</a>，这里的实现参考 <a target="_blank" rel="noopener" href="https://github.com/ithewei/libhv/blob/6cf0ce0eb09caf779d5524c154d2166d9aab7299/cpputil/hurl.cpp">libhv&#x2F;cpputil&#x2F;hurl.cpp</a>。</p>
<p>关于 HTTP 请求头可以参考 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header">Http Request</a>，关于 HTTP parser 的实现可以参考 <a target="_blank" rel="noopener" href="https://github.com/nodejs/http-parser">nodejs&#x2F;http-parser</a>、<a target="_blank" rel="noopener" href="https://github.com/nodejs/llhttp">nodejs&#x2F;llhttp</a>。</p>
<h3 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h3><p>到了 HttpResponse 就简单多了，它只负责生成 <code>HTTP</code> 响应头和保存响应体（或响应体的抽象）。</p>
<p>响应体的类型分别有 Text（文本）、Stream（标准流）、File（文件）。原本是打算用 union 实现这个多类型响应体，由于不是类型安全加上成员隐式构造函数的问题于是放弃了。然后把目光投向了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/variant">std::variant</a>，但是 <code>C++17</code> 实现的 std::variant 性能不高，也放弃了。最后只好自己用 struct 手撸了一个<del>类型安全的</del>“联合”。</p>
<p>剩下的就是 HttpResponse::toRawData()。顾名思义，这个函数是将 HttpResponse 转换为完整的 <code>HTTP</code> 响应（或响应头部），至于实现就用 std::string::append() 按照标准把响应拼接出来就好啦。</p>
<p>关于 <code>HTTP</code> 响应头可以参考 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Response_header">Http Response</a>。</p>
<h3 id="HttpServices"><a href="#HttpServices" class="headerlink" title="HttpServices"></a>HttpServices</h3><p>HttpServices 是 AbstractServices 的派生类，负责保存不同的业务 handler。在 HttpServices::process() 中会调用业务 handler 和处理 <code>HTTP</code> 业务的相关逻辑。</p>
<p>首先是业务 handler 的存储。这里用的是两个 Map 嵌套的方式：</p>
<pre><code class=" mermaid">graph LR
    subgraph m_services
    Method

    subgraph uriHandler
        URI --found--&gt; Handler
        URI -.not found.-&gt; DefaultHandler
    end

    Method --&gt; URI
    end</code></pre>

<hr>
<p>在 HttpServices::process() 中首先会调用 AbstractSocket::read() 接收请求并调用 HttpRequest::parse() 解析请求，接着调用 HttpServices::callHandler() 调用业务处理代码，然后调用 HttpResponse::toRawData() 转换成 <code>HTTP</code> 响应，最后调用 AbstractSocket::write()、AbstractSocket::sendStream()、AbstractSocket::sendFile() 发送响应头和响应体。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="关于-Epoll"><a href="#关于-Epoll" class="headerlink" title="关于 Epoll"></a>关于 Epoll</h3><p>关于 Epoll 的好处<del>人尽皆知</del>，难道它就没有问题吗？当然不是。  </p>
<p>如果把 AbstractSocket* 放进 epoll_event::data::ptr 里，乍一看很优雅，不用外部维护一个 Map 映射 fd 和 AbstractSocket 了。当 close epoll fd 的时候 epoll_event::data::ptr 指向的内存并不会自动释放，而且我们不能遍历 epoll 内部维护的二叉树释放内存，因此造成内存泄漏。所以必须要存在外部的 holder（在这个项目中是 TimerManager） 控制 AbstractSocket 的生命周期（kqueue 亦是如此）。</p>
<p>其次，epoll_ctl 是 <code>syscall</code> 且一次只能处理一个描述符。这就意味着当 epoll 面对大量短链接的时候需要频繁陷入内核，浪费大量的 CPU 周期，导致性能下降（kevent 的设计就避免了这个问题）。</p>
<p>关于 Epoll 设计缺陷更完整的讨论可以看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a109016.html">盘点LinuxEpoll那些致命弱点</a></li>
<li><a target="_blank" rel="noopener" href="https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/">Epoll is fundamentally broken 1&#x2F;2</a></li>
<li><a target="_blank" rel="noopener" href="https://idea.popcount.org/2017-03-20-epoll-is-fundamentally-broken-22/">Epoll is fundamentally broken 2&#x2F;2</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40096515">IO完成端口(IOCP)</a></li>
</ul>
<p>更多的并发模型可以看：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/364819119">AIO</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62682475">io_uring</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77206570">Go 并发模型</a>。</p>
<h3 id="亿些教训"><a href="#亿些教训" class="headerlink" title="亿些教训"></a>亿些教训</h3><h4 id="glibc-malloc"><a href="#glibc-malloc" class="headerlink" title="glibc malloc()"></a>glibc malloc()</h4><p>既然用的是 C++ 就肯定少不了喜闻乐见的内存安全问题。当你遇到下面的报错会怎么办呢：</p>
<blockquote>
<p>malloc(): unaligned tcache chunk detected</p>
</blockquote>
<p>经过一番查找和询问，初步判断是 out of range 或 use after free。</p>
<p>原因大概知道了，那么如何定位呢？最开始是用 GDB 定位，结果每次都定位到 STL 的一些 construction 里面。我百思不得其解，然后挂上了 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/360135083">asan</a>，结果还是令人失望，打印了几行信息之后就没反应了，后面上了 Valgrind 也是一样（毕竟是 asan 的亲爹，当然也可能是我的操作有问题qwq）。进度就这样被搁置了一个星期，我甚至开始想停掉这个项目了，因为一个不能稳定运行的 Server 没有任何意义。最后还是决定去 commit history 碰碰运气（因为之前是没问题的）。</p>
<p>结果还真找到了，在这个 <a target="_blank" rel="noopener" href="https://github.com/ho-229/Network-Learn/commit/7deee7416aa817bbe1bea502b4c400891b28856b">commit</a> 中我忽略了 Timer 被释放之后 AbstractSocket 依旧持有它的指针的问题，导致了 use after free，真的是血的教训…</p>
<p>从 commit history 找 bug 算是一个比较通用的手段，如果你也遇到了类似的难题不妨试试这个方法。关于 tcache 我的了解不多，下面是一些参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365170777">从 VNCTF2021-ff 浅析 libc2.32 下 ptmalloc 新增的防护之指针异或加密</a></li>
<li><a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.15_vsyscall_vdso.html">glibc tcache 机制</a></li>
<li><a target="_blank" rel="noopener" href="https://ctf-wiki.org/en/pwn/linux/user-mode/heap/ptmalloc2/implementation/tcache/">tcache - CTF wiki</a></li>
</ul>
<h4 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h4><p>你以为到这就完了吗，我在早期还踩过一个大坑，这个坑是关于 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/future">std::future</a> 的。</p>
<p>当时是为了实现 <code>keep alive</code>。实现是在一个循环里调用 accept()，然后调用 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/async">std::async()</a> 创建线程处理新链接的所有 <code>HTTP</code> 业务。结果是浏览器并不会复用这个链接反而是关闭它发起一个新链接。最后在求助我师傅 <a target="_blank" rel="noopener" href="https://github.com/NiceBlueChai">@NiceBlueChai</a> 的时候，他在 <code>HTTP</code> 业务里输出线程 ID 马上发现了问题：<strong>我只创建了一个线程！而且创建线程和调用 accept 的循环被 std::future 的析构函数阻塞了！</strong> 我做梦也想不到 std::future 析构函数会阻塞。当浏览器发起第二个链接的时候会 Pending（因为服务器的 accept 不会被执行），然后它会主动断开第一个链接并重连。</p>
<p>在做这个项目的时候踩过的坑远不止一点点，比如说前面提到的 Windows 和 *nix 的 accept 行为不一致…</p>
<h2 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h2><p>嘛，最后祝大家 Debug 一帆风顺，能够专心做自己想做的事情。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/code/" class="category-chain-item">code</a>
  
  
    <span>></span>
    
  <a href="/categories/code/network/" class="category-chain-item">network</a>
  
  
    <span>></span>
    
  <a href="/categories/code/network/server/" class="category-chain-item">server</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/WebServer/" class="print-no-link">#WebServer</a>
      
        <a href="/tags/HTTP/" class="print-no-link">#HTTP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>关于一个 Tiny Web Server 的实现</div>
      <div>https://ho-229.github.io/code/network/server/tiny-web-server/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ho 229</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年1月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/web3/service/deploying/deploy-matrix/" title="记一次 Matrix Dendrite 的部署（SQLite 版）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">记一次 Matrix Dendrite 的部署（SQLite 版）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/code/Qt/qt-crawler/" title="Qt 爬虫">
                        <span class="hidden-mobile">Qt 爬虫</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'ho-229/blog-repo');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'comments');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
