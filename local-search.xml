<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>东京圣地巡礼 2024.06</title>
    <link href="/travel/pilgrimage-202406-tokyo/"/>
    <url>/travel/pilgrimage-202406-tokyo/</url>
    
    <content type="html"><![CDATA[<h2 id="孤独摇滚！"><a href="#孤独摇滚！" class="headerlink" title="孤独摇滚！"></a>孤独摇滚！</h2><p><img src="/image/a_shimo_kitazawa.jpg"><br><img src="/image/r_shimo_kitazawa.jpg"></p><hr><p><img src="/image/a_honda.jpg"><br><img src="/image/r_honda.jpg"></p><hr><div style="text-align:center"><span style="width:49%;display:inline-block"><p><img src="/image/a_shelter.jpg"></p></span><span style="width:49%;display:inline-block"><p><img src="/image/r_shelter.jpg"></p></span></div><hr><p><img src="/image/a_group_photo.jpg"><br><img src="/image/r_group_photo.jpg"></p><h2 id="路人女主的养成方法"><a href="#路人女主的养成方法" class="headerlink" title="路人女主的养成方法"></a>路人女主的养成方法</h2><div style="text-align:center"><span style="width:49%;display:inline-block"><p><img src="/image/a_downhill.jpg"></p></span><span style="width:49%;display:inline-block"><p><img src="/image/r_downhill.jpg"></p></span></div><h2 id="LoveLive-Sunshine"><a href="#LoveLive-Sunshine" class="headerlink" title="LoveLive! Sunshine!!"></a>LoveLive! Sunshine!!</h2><p><img src="/image/a_jr_akihabara.jpg"><br><img src="/image/r_jr_akihabara.jpg"></p><h2 id="LoveLive-虹咲学园校园偶像同好会"><a href="#LoveLive-虹咲学园校园偶像同好会" class="headerlink" title="LoveLive! 虹咲学园校园偶像同好会"></a>LoveLive! 虹咲学园校园偶像同好会</h2><p><img src="/image/a_exchange_ct.jpg"><br><img src="/image/r_exchange_ct.jpg"></p><hr><p><img src="/image/a_park_bench.jpg"><br><img src="/image/r_park_bench.jpg"></p><hr><p><img src="/image/a_venue.jpg"><br><img src="/image/r_venue.jpg"></p><h2 id="莉可丽丝"><a href="#莉可丽丝" class="headerlink" title="莉可丽丝"></a>莉可丽丝</h2><p><img src="/image/a_oshiage_sta.jpg"><br><img src="/image/r_oshiage_sta.jpg"></p><hr><p><img src="/image/a_sumida_1.jpg"><br><img src="/image/r_sumida_1.jpg"></p><hr><p><img src="/image/a_sumida_2.jpg"><br><img src="/image/r_sumida_2.jpg"></p><hr><p><img src="/image/a_skytree.jpg"><br><img src="/image/r_skytree.jpg"></p><h2 id="少女歌剧"><a href="#少女歌剧" class="headerlink" title="少女歌剧"></a>少女歌剧</h2><div style="text-align:center"><span style="width:60%;display:inline-block"><p><img src="/image/a_skytree_2.jpg"></p></span><span style="width:39%;display:inline-block"><p><img src="/image/r_skytree_2.jpg"></p></span></div><h2 id="天使的心跳！"><a href="#天使的心跳！" class="headerlink" title="天使的心跳！"></a>天使的心跳！</h2><p><img src="/image/a_shibuya109.jpg"><br><img src="/image/r_shibuya109.jpg"></p><h2 id="青春猪头少年不会梦到兔女郎学姐"><a href="#青春猪头少年不会梦到兔女郎学姐" class="headerlink" title="青春猪头少年不会梦到兔女郎学姐"></a>青春猪头少年不会梦到兔女郎学姐</h2><p><img src="/image/a_high_school.jpg"><br><img src="/image/r_high_school.jpg"></p><hr><p><img src="/image/a_beach.jpg"><br><img src="/image/r_beach.jpg"></p><hr><p><img src="/image/a_seaside.jpg"><br><img src="/image/r_seaside.jpg"></p><hr><p><img src="/image/a_yukiai_bridge.jpg"><br><img src="/image/r_yukiai_bridge.jpg"></p><hr><p><img src="/image/a_shichirigahama_sta.jpg"><br><img src="/image/r_shichirigahama_sta.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://anitabi.cn/map">动画巡礼地图</a></p>]]></content>
    
    
    <categories>
      
      <category>travel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>anime-pilgrimage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次 Matrix Dendrite 的部署（SQLite 版）</title>
    <link href="/web3/service/deploying/deploy-matrix/"/>
    <url>/web3/service/deploying/deploy-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://matrix-org.github.io/dendrite/">Dendrite</a> 是用 Go 写成的第二代 <a href="https://matrix.org/docs/guides/introduction#how-does-it-work">Matrix homeserver</a>，今天就来踩个坑。</p><span id="more"></span><p>整个部署流程基于官方的 <a href="https://github.com/matrix-org/dendrite#get-started">Get started</a>。</p><h2 id="编译与生成密钥"><a href="#编译与生成密钥" class="headerlink" title="编译与生成密钥"></a>编译与生成密钥</h2><p>编译和生成密钥的时候没有遇到啥问题。</p><p>我使用的环境是 AWS 的 1g1c 小鸡，系统是 Ubuntu 22.04-amd64，Go 版本是 1.18.1 linux&#x2F;amd64。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><p>在编译和生成密钥完成后，运行 <code>dendrite-monolith-server</code> 会出现以下报错：</p><blockquote><p>PANI[2022-11-02T05:02:46.231645575Z] Failed to set up global database connections  error&#x3D;”failed to find maximum connections: dial tcp: lookup hostname: no such host”<br>panic: (*logrus.Entry) 0xc0002a5c70<br>…</p></blockquote><p>由于这个报错很模糊，也可能是因为我是新手，所以我并没有从网上找到有用的东西。阅读了它的源代码之后发现是在执行 config 的时候 panic 的，那就说明官方给的 <code>dendrite-sample.monolith.yaml</code> 是不能直接用的。</p><p>打开 YAML 一看，发现它直接在 <code>global.database</code> 里用了 PostgreSQL，但是我并不打算用 PostgreSQL 部署。研究了一下注释之后发现 <code>global.database</code> 是 PostgreSQL 专属的， SQLite 不能用 <code>global.database</code>（也就是 Dendrite 的 Global database connection pool），且只能手动给每个 component 指定 database，也就是在每个 component 下面加：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">database:</span>  <span class="hljs-attr">connection_string:</span> <span class="hljs-string">file:dendrite_&lt;component&gt;.db</span>  <span class="hljs-attr">max_open_conns:</span> <span class="hljs-number">10</span>  <span class="hljs-attr">max_idle_conns:</span> <span class="hljs-number">2</span>  <span class="hljs-attr">conn_max_lifetime:</span> <span class="hljs-number">-1</span></code></pre></div><p>需要注意的是，每个 component 不能和其它 component 用同一个 .db，同时 <code>global.database</code> 也要注释掉。</p><h3 id="添加缺失的-compenet-配置"><a href="#添加缺失的-compenet-配置" class="headerlink" title="添加缺失的 compenet 配置"></a>添加缺失的 compenet 配置</h3><p>再次运行 <code>dendrite-monolith-server</code> 又会得到下面的报错：</p><blockquote><p>INFO[2022-11-02T05:25:53.722317580Z] Dendrite version 0.10.5+8c7b274e<br>PANI[2022-11-02T05:25:53.756013624Z] failed to connect to room server db           error&#x3D;”sqlutil.Open: no database connections configured”<br>…</p></blockquote><p>然而在我的 YAML 里面并没有关于 room server 的配置，很显然 example 是漏了一些字段。于是我去网上找了一份也是用 SQLite 的 Dendrite <a href="https://codeberg.org/gerald/dendrite-on-flyio/src/branch/main/dendrite-example.yaml">配置文件</a>，对比之后发现 example 少了 <code>room_server</code> 和 <code>key_server</code> 两个 component 的配置，还有 <code>user_api.account_database</code> 和 <code>user_api.device_database</code>。</p><p>解决方法是按照网上的配置文件补上即可，注意修改 <code>database.connection_string</code> 的路径。</p><p>再次运行 <code>dendrite-monolith-server</code>，server 已经顺利跑起来了。地址是 <a href="http://localhost:8008/">http://localhost:8008</a>。</p><h2 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h2><p>按照 <a href="https://github.com/matrix-org/dendrite#get-started">Get started</a> 的最后一步创建账号会出现以下错误：</p><blockquote><p>FATA[0000] Shared secret registration is not enabled, enable it by setting a shared secret in the config: ‘client_api.registration_shared_secret’</p></blockquote><p>这个报错就说得很清楚了，是因为没有在 YAML 里设置 <code>client_api.registration_shared_secret</code>。解决办法是写一段随机字符串作为 shared secret。</p><h3 id="公开账号注册"><a href="#公开账号注册" class="headerlink" title="公开账号注册"></a>公开账号注册</h3><p>如果你希望能在客户端注册账号而不是在服务器上，你需要公开账号注册。</p><p>公开账号注册有两种方法：</p><ol><li><em>（不安全）</em> 将 YAML 里的 <code>client_api.registration_disabled</code> 设为 <code>false</code>，然后在 <code>dendrite-monolith-server</code> 的启动参数添加 <code>-really-enable-open-registration</code>。</li><li><a href="https://matrix-org.github.io/dendrite/administration/registration">Enable reCAPTCHA verification registration</a>。</li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在部署之前记得把 <code>global.server_name</code>、<code>global.well_known_server_name</code> 和 <code>global.well_known_client_name</code> 改成自己 server 的 domain。</p><p>使用 <code>-http(s)-bind-address</code> 可以更改 HTTP(S) 的端口，HTTP 端口默认是 8008，HTTPS 端口默认是 8448。</p><h2 id="Integration-Manager"><a href="#Integration-Manager" class="headerlink" title="Integration Manager"></a>Integration Manager</h2><p>目前 Matrix 主流的 integration manager 是 <a href="https://github.com/turt2live/matrix-dimension">Dimension</a>。</p><p>如果要部署 integration manager，需要用 Nginx 反向代理把 Dimension 的端口映射到 443 （或 80），具体方法可以看 <a href="https://github.com/turt2live/matrix-dimension/blob/master/docs/installing.md">Installing Dimension</a>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>测试使用的客户端分别是 Android 和 Desktop 版的 <a href="https://element.io/">Element</a>。</p><p>测试发现 Android 端的电话图标和视频图标发起的分别是电话会议和视频会议，而 Desktop 端的是语言和视频通话。其中 Desktop 端发起的视频通话无法接通，会一直处于 connecting 的状态。</p><h2 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h2><p><a href="https://lemonhx.moe/2022/11/04/fuckmatrix/">Evil version</a></p>]]></content>
    
    
    <categories>
      
      <category>web3</category>
      
      <category>service</category>
      
      <category>deploying</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web3</tag>
      
      <tag>Matrix</tag>
      
      <tag>Dendrite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于一个 Tiny Web Server 的实现</title>
    <link href="/code/network/server/tiny-web-server/"/>
    <url>/code/network/server/tiny-web-server/</url>
    
    <content type="html"><![CDATA[<p>鸽了两年的 blog，我终于回来辣（</p><p>这篇 blog 是关于自己胡的一个玩具 HTTP Server。做这个项目的想法来源于 CS:APP 的 TINY Web 服务器实践。（当时感觉挺简单的，现在回头一看全是坑qwq）</p><span id="more"></span><blockquote><p>友情提示：此篇 blog 废话较多。作者不是计算机专业的学生，也不从事计算机方面的工作。为节约您的宝贵时间，请酌情观看。</p></blockquote><p>项目地址： <a href="https://github.com/ho-229/Network-Learn">https://github.com/ho-229/Network-Learn</a></p><h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><pre><code class=" mermaid">flowchart TB    main((&quot;main()&quot;)) --Thread 0--&gt; listen[&quot;WebServer::listen()&quot;];    subgraph exec[&quot;WebServer::exec()&quot;]        start[&quot;WebServer::start()&quot;]        subgraph loop0[&quot;EventLoop::exec()&quot;]            direction LR            epoll[&quot;Epoll::epoll()&quot;]            subgraph process[&quot;EventLoop::processQueue()&quot;]                accept[&quot;AbstractSocket::accept()&quot;]                services[&quot;AbstractServices::process()&quot;]            end            epoll --isListener--&gt; accept            epoll --clientSocket--&gt; services            process --&gt; epoll        end        subgraph loopN[&quot;EventLoop::exec()&quot;]            ...        end                start --Thread 1--&gt; loop0        start --Thread N--&gt; loopN        wait[&quot;WebServer::waitForFinished()&quot;]        loop0 --&gt; wait        loopN --&gt; wait    end    listen --&gt; start    wait --&gt; e((exit))</code></pre><p>先来看看大致的并发模型，其思想是 <code>one loop per thread</code>。在 WebServer::start() 中创建了 N 个工作线程和 EventLoop，然后将 listeners 分发到每一个 EventLoop。在 EventLoop::exec() 中循环调用 Epoll::epoll() 等待请求到达，并调用 AbstractServices::process() 处理 I&#x2F;O 和协议相关的业务。</p><p>这种多线程 + <a href="#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8F%8A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%AE%9E%E7%8E%B0">I&#x2F;O 多路复用</a> 的并发模型类似于 Nginx（把进程换成了线程）。每个 EventLoop 之间相互独立，所以工作线程之间没有显式的同步代码，也没有切换进程上下文开销。</p><h2 id="Socket-抽象及跨平台实现"><a href="#Socket-抽象及跨平台实现" class="headerlink" title="Socket 抽象及跨平台实现"></a>Socket 抽象及跨平台实现</h2><pre><code class=" mermaid">classDiagram    direction LR    class AbstractSocket &#123;        +read(buf, size)* ssize_t        +write(buf, size)* ssize_t        +close()*        +sslEnable()* bool        +isValid()* bool        +sendFile(file, offset, count)* ssize_t        +listen(hostName, port) bool        +accpet() Socket        -AbstractSocket()        #Socket m_descriptor        #bool m_isListener    &#125;    class TcpSocket &#123;        +TcpSocket()    &#125;    class SslSocket &#123;        +SslSocket()        +initializatSsl(certFile, privateKey)$ bool        +cleanUpSsl()$        +sslVersion()$ string        +isSslAvailable()$ bool        -SSL m_ssl        -SSL_CTX sslContext$    &#125;    AbstractSocket &lt;|-- TcpSocket : implements    AbstractSocket &lt;|-- SslSocket : implements</code></pre><p>AbstractSocket 的两个派生类分别是 TcpSocket 和 SslSocket，分别是 <code>TCP</code> 和 <code>SSL</code> 链接的跨平台实现。</p><p>TcpSocket 的构造函数什么也不做，而 SslSocket 的构造函数会调用 SSL_accept() 完成 <code>SSL</code> 握手。</p><p>AbstactScoket::read() 和 AbstractSocket::write() 是 <code>RIO</code>（自动处理不足值） 跨平台实现的抽象接口。<br>TcpSocket 在 Linux 上使用 <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> 和 <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>，在 Windows 上使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv">recv()</a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-send">send()</a>；<br>SslSocket 使用 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_read.html">SSL_read()</a> 和 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_write.html">SSL_write()</a> 实现。需要注意的是某些 API 的 size 和返回值类型是 int，直接传参可能会导致整数溢出 <del>（屑 Windows 和屑 OpenSSL）</del>。</p><p>AbstractSocket::sendFile() 是发送文件（Handle 或 file descriptor）的 <code>RIO</code> 抽象接口。TcpSocket::sendFile() 在 Linux 上使用 <a href="https://linux.die.net/man/2/sendfile64">sendfile64()</a>（sendfile64 和其他 I&#x2F;O 函数一样会返回不足值）；其余平台和 SslSocket 的实现都是 <a href="https://www.man7.org/linux/man-pages/man2/mmap.2.html">mmap</a> + AbstractSocket::write()。这里会有几个问题：</p><ol><li>为什么要用 sendfile64 呢？因为它 <del>（方便，快）</del> 是 Linux 提供的一个在两个文件描述符之间传递数据的“零拷贝”函数（也是 <code>syscall</code>）。在最新的实现中，它通过设置 <code>DMA</code> 将数据从 <code>kernel buffer</code> 直接传输到协议引擎。</li><li>为什么 Linux 上的 SslSocket::sendFile() 不能用 sendfile64 实现呢？因为 sendfile64 不支持对数据进行 <code>SSL</code> 加密。实际上在 OpenSSL 3.0.0+ 的版本中添加了 <a href="https://beta.openssl.org/docs/manmaster/man3/SSL_sendfile.html">SSL_sendfile()</a> 这个 API，但是 OpenSSL 3 尚未普及且需要 <code>kernel TLS/SSL</code> 支持。</li><li>为什么其他的实现要用 mmap + AbstractSocket::write() 而不是 read() + AbstractSocket::write() 呢？主要是因为 mmap 不会改变文件描述符的 seek ，也不会受其影响；其次是 mmap 比 read() 少了一次从 <code>kernel buffer</code> 到 <code>user buffer</code> 的复制。</li></ol><p>AbstractSocket::listen() 是与协议版本无关的监听函数，具体实现可以参考 CS:APP 第三版 P662 的 open_listenfd。<br>AbstractSocket::accept() 会非阻塞地返回一个连接描述符（如果没有则返回错误码）。需要注意的是 Windows 的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept">accept()</a> 返回的套接字会继承 listener 的（非）阻塞状态而 *nix 的 accept() 则不会。所以在 Linux 下需要调用 <a href="https://linux.die.net/man/2/accept4">accept4()</a> （Linux 的私货）将返回的连接描述符设置为非阻塞，如果是 Unix 系的话就只能在 accept() 之后再调用 fcntl() 将连接套接字设置为非阻塞。</p><h2 id="I-O-多路复用及跨平台实现"><a href="#I-O-多路复用及跨平台实现" class="headerlink" title="I&#x2F;O 多路复用及跨平台实现"></a>I&#x2F;O 多路复用及跨平台实现</h2><p>为什么要使用 I&#x2F;O 多路复用呢，一个线程一个 connection 不香么？（doge<br>如果你的服务器上有 10000 个链接，这就意味着你需要开 10000 个线程（C10K）。<del>众所周知，</del> 大量的线程就意味着大量的线程上下文切换，不仅会浪费大量 CPU 周期，还会浪费内存空间。所以我们需要一个线程能够处理多个 I&#x2F;O，这就是 I&#x2F;O 多路复用。</p><p>由于这个项目是跨平台项目，然而各个平台优秀的本地接口又各不相同，于是就有了 Epoll 类用来封装跨平台实现。</p><p>类 Epoll 主要负责管理 AbstractSocket 的可读和错误（链接断开）事件。Epoll::insert() 和 Epoll::erase() 分别是将套接字添加&#x2F;移出 Epoll。Epoll::epoll() 负责返回可读套接字和发生错误的套接字。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// /TinyWebServer/src/core/epoll.h</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Epoll</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Epoll</span><span class="hljs-params">()</span></span>;    ~<span class="hljs-built_in">Epoll</span>();    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(AbstractSocket *<span class="hljs-type">const</span> socket, <span class="hljs-type">bool</span> exclusive = <span class="hljs-literal">false</span>)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(AbstractSocket *<span class="hljs-type">const</span> socket)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">epoll</span><span class="hljs-params">(std::vector&lt;AbstractSocket *&gt; &amp;events,</span></span><span class="hljs-params"><span class="hljs-function">               std::vector&lt;AbstractSocket *&gt; &amp;errorEvents)</span></span>;    <span class="hljs-comment">// snip</span>&#125;;</code></pre></div><h3 id="Windows（WSAPoll）"><a href="#Windows（WSAPoll）" class="headerlink" title="Windows（WSAPoll）"></a>Windows（WSAPoll）</h3><p>由于 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsapoll">WSAPoll</a> 自身并不维护队列，所以我们要自行维护一个 pollfd 线性队列和一个 <code>fd -&gt; AbstractSocket*</code> 的 Map（以便用 fd 能找到 AbstractSocket*），然后在 Epoll::insert 和 Epoll::erase 中操作它们（如果可能被异步访问还要给数据结构加锁），最后在 Epoll::epoll 中调用 WSAPoll()。</p><p>用 WSAPoll 实现会导致低效的一个原因是当调用 Epoll::erase 的时候需要遍历 pollfd 队列找到要删除的元素，然后把在它之后的元素向前移动一遍，还有一个原因是 WSAPoll 没有办法避免惊群 ㄟ( ▔, ▔ )ㄏ。</p><h3 id="Linux（epoll）"><a href="#Linux（epoll）" class="headerlink" title="Linux（epoll）"></a>Linux（epoll）</h3><p>到了 <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> 就简单了许多，因为它会维护一个红黑树。我们只需要把 AbstractSocket* 传给 epoll_event::data::ptr，在 Epoll::insert 和 Epoll::erase 中只需要把 epoll_ctl 封装一下，然后在 Epoll::epoll 中调用 epoll_wait。</p><p>接下来就是 epoll 高效的秘密了。epoll 的边缘触发（<code>EPOLLET</code>）可以让一个事件在新的事件到来之前只触发一次，比起水平触发来说就少了许多冗余事件。还有一个是在 Linux 4.5+ 提供的 <code>EPOLLEXCLUSIVE</code>，它能使被监听的套接字只能触发一个 epoll，完美解决了惊群问题。更低版本的 Linux 可以让每个 EventLoop 持有一组 listeners 并设置 <code>SO_REUSEPORT</code> 让它们能监听同一组端口。</p><p><a href="#%E5%85%B3%E4%BA%8E-epoll">关于 Epoll 的碎碎念</a></p><h3 id="Unix-MacOS-BSD（kqueue）"><a href="#Unix-MacOS-BSD（kqueue）" class="headerlink" title="Unix &#x2F; MacOS &#x2F; BSD（kqueue）"></a>Unix &#x2F; MacOS &#x2F; BSD（kqueue）</h3><p>到了 <a href="https://man.openbsd.org/kqueue.2">kqueue</a> 事情变得更简单了，因为它只有两个 API！kqueue() 和 kevent()。和 Epoll 一样，kqueue 也会自己维护队列，在 struct kevent 中也同样有存放用户数据结构指针的地方，不同的是 Epoll::insert、Epoll::erase 和 Epoll::epoll 都是 kevent() 的封装。</p><p>从接口设计上来说 kqueue 比 epoll 更高效。一次 kqueue 调用不仅可以同时增加&#x2F;删除多个套接字，还能获取活动事件队列，不过要注意的是，更改的事件只能在下次 kqueue 调用才会生效。kqueue 提供了一个 <code>EV_CLEAR</code> 标志用于实现类似于 <code>EPOLLET</code> 的语义，它的行为是当事件被用户捕获时清除其状态。至于惊群问题就比较遗憾了，kqueue 没有提供类似 <code>EPOLLEXCLUSIVE</code> 的标志，而且在 MacOS 11 上用 <code>SO_REUSEPORT</code> 也没办法解决惊群问题。</p><p>虽然但是，kqueue 还是提供了强大的 filter，目前为止我们只使用了 kqueue 的一小部分特性。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/127148459">深入学习理解 IO 多路复用</a></li><li><a href="https://blog.csdn.net/dream0130__/article/details/104009426">epoll在多线程中的应用-EPOLLEXCLUSIVE和REUSEPORT(一)</a></li><li><a href="https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/">Why does one NGINX worker take all the load?</a></li></ul><h2 id="EventLoop-及-Timer-实现"><a href="#EventLoop-及-Timer-实现" class="headerlink" title="EventLoop 及 Timer 实现"></a>EventLoop 及 Timer 实现</h2><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// /TinyWebServer/src/core/eventloop.cpp</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::exec</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(m_runnable &amp;&amp; m_epoll.<span class="hljs-built_in">count</span>())    &#123;        m_epoll.<span class="hljs-built_in">epoll</span>(m_queue, m_errorQueue);        <span class="hljs-keyword">if</span>(!m_queue.<span class="hljs-built_in">empty</span>())            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">processQueue</span>();        <span class="hljs-keyword">if</span>(!m_errorQueue.<span class="hljs-built_in">empty</span>())            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">processErrorQueue</span>();        <span class="hljs-comment">// Clean up timeout connections</span>        m_manager.<span class="hljs-built_in">checkout</span>(m_errorQueue);        <span class="hljs-keyword">if</span>(!m_errorQueue.<span class="hljs-built_in">empty</span>())            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">processTimeoutQueue</span>();    &#125;&#125;</code></pre></div><p>进入 EventLoop::exec() 后，先用 Epoll::epoll() 获取可读套接字队列和错误&#x2F;已关闭套接字队列。</p><p>在 EventLoop::processQueue() 中会遍历 m_queue（可读套接字队列）。<br>如果 AbstractSocket 为 listener，就会循环调用 AbstractSocket::accept() 获取新的客户端的套接字描述符直到返回 INVALID_SOCKET，如果 listener 的 sslEnable() 为真会创建一个 SslSocket 对象，反之会创建 TcpSocket 对象，然后为它设置一个 timer 并调用 Epoll::insert()，最后触发 ConnectEvent::Accept；<br>如果 AbstractSocket 为客户端套接字，调用 AbstractServices::process() 处理业务。如果业务处理成功就调用 TimerManager::restart()，如果不成功将会调用 Epoll::erase() 和 TimerManager::destroy()，并触发 ConnectEvent::Close，最后释放套接字内存。</p><p>在 EventLoop::processErrorQueue() 中会遍历 m_errorQueue（错误&#x2F;已关闭套接字队列），如果 AbstractSocket 为 listener 会发出一个 ExceptionEvent::ListenerError，反之会触发 ConnectEvent::Close 并关闭它们。</p><p>处理超时链接会调用 TimerManager::checkout() 获取不活跃套接字队列，然后调用 EventLoop::processTimeoutQueue() 关闭它们，流程和 EventLoop::processErrorQueue() 类似但不需要判断是否为 listener，因为 listener 不会被放进 TimerManager 里。</p><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// /TinyWebServer/src/util/timermanager.h</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> TimeType&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">const</span> TimeType&amp; timeout, <span class="hljs-type">const</span> T&amp; data)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; <span class="hljs-title">deadline</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> T&amp; <span class="hljs-title">userData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Timer&lt;T, TimeType&gt; &amp;right) <span class="hljs-type">const</span>;    <span class="hljs-comment">// snip</span>&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerManager</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> TimerItem = Timer&lt;T, TimeType&gt;;    <span class="hljs-keyword">using</span> iterator = <span class="hljs-keyword">typename</span> std::list&lt;TimerItem&gt;::iterator;    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TimerManager</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function">iterator <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">const</span> TimeType&amp; timeout, <span class="hljs-type">const</span> T&amp; data)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">(iterator timerIt)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">(iterator it)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkout</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; list)</span></span>;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function">T <span class="hljs-title">takeFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// snip</span>&#125;;</code></pre></div><p>在 TimerManager 中会维护一个 Timer 队列（按 deadline 从低到高）。用 std::list 实现的原因是因为它的 insert 和 erase 是常量时间开销且迭代器不会失效，而且它还提供了 <a href="https://en.cppreference.com/w/cpp/container/list/splice">std::list::splice()</a> 可以在迭代器不失效的前提下移动位置。</p><p>调用 TimerManager::start() 时会根据 timeout 创建一个 Timer 插入到队列中并返回它的迭代器。这个迭代器会被保存在 AbstractSocket 里。当 AbstractSocket 触发错误事件时可以通过 AbstractSocket::timer() 找到它的 timer 并用 TimerManager::destory() 删除它。</p><p>TimerManager::restart() 会调用给定 Timer 的 Timer::reset() 重置它的 deadline，并将它在队列中重新排序。</p><p>在 TimerManager::checkout() 中会检查队列的第一个 Timer。如果当前时间大于 Timer::deadline() 则视为超时，此时会将 Timer::userData() 加入 list 并 pop。重复上述操作直到第一个 Timer 不再超时或队列为空。</p><p>TimerManager::takeFirst() 会返回第一个 Timer 所持有的 userData 并 pop_front。它会在 EventLoop 析构的时候被调用，以释放 AbstractSocket 所占的内存。</p><h2 id="HTTP-实现"><a href="#HTTP-实现" class="headerlink" title="HTTP 实现"></a>HTTP 实现</h2><p>在谈 HttpRequest 和 HttpResponse 之前，我们先来聊聊 <code>HTTP header</code> 的存储（因为它俩的实现都要用到）。</p><p>众所周知，<code>HTTP header</code> 是不区分大小写的，如果我们想用 Map 来存储 header（name -&gt; value），要么把查询和储存都转成大&#x2F;小写，要么做忽略大小写的匹配。这里我选择了第二种处理方式，因为这种方式没有对原数据和查询数据的修改。但是 STL 中并没有这方面的支持。对于 <a href="https://zh.cppreference.com/w/cpp/container/map">std::map</a>，我们需要自定义 Compare；对于 <a href="https://zh.cppreference.com/w/cpp/container/unordered_map">std::unordered_map</a>，我们需要自定义 Compare 和 Hasher。</p><p>先说 Compare。实际上 std::map 和 std::unordered_map 的 Compare 是不一样的（因为一个是二叉树一个是哈希表），所以 std::map 的 Compare 是比较谁大（或谁小），而 std::unordered_map 的是比较两个值是否相等。虽然 STL 并没有提供忽略大小写比较字符串的 functor，但是在 string.h 中提供了相关函数，也就是说我们只需要做跨平台封装就行了，在 Windows 上是 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strnicmp-wcsnicmp-mbsnicmp-strnicmp-l-wcsnicmp-l-mbsnicmp-l?view=msvc-170">_strnicmp()</a>，在 Linux 上是 <a href="https://linux.die.net/man/3/strncasecmp">strncasecmp()</a>。细心的你一定会发现用的都是带 size 参数的版本，这是因为带边界检查可以避免很多潜在问题，比如说比较的字符串不是以 \0 结尾…</p><p>然后就是 Hasher，这里实现是用 Key 的第一个字母的小写作为哈希值（<del>至于碰撞嘛，能用就行</del>。</p><h3 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h3><p>HttpRequest 主要的功能是解析及保存 <code>HTTP</code> 请求。</p><p>关于 parser 的细节就不过多介绍了（因为这方面我不在行，而且手写 parser 真的是噩梦），这个 parser 虽然不是用状态机实现的，但是运行起来也近似于状态机。接下来是关于 <code>URI</code> 的转义处理，转义标准可以参考 <code>JavaScript</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI">decodeURI</a>，这里的实现参考 <a href="https://github.com/ithewei/libhv/blob/6cf0ce0eb09caf779d5524c154d2166d9aab7299/cpputil/hurl.cpp">libhv&#x2F;cpputil&#x2F;hurl.cpp</a>。</p><p>关于 HTTP 请求头可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header">Http Request</a>，关于 HTTP parser 的实现可以参考 <a href="https://github.com/nodejs/http-parser">nodejs&#x2F;http-parser</a>、<a href="https://github.com/nodejs/llhttp">nodejs&#x2F;llhttp</a>。</p><h3 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h3><p>到了 HttpResponse 就简单多了，它只负责生成 <code>HTTP</code> 响应头和保存响应体（或响应体的抽象）。</p><p>响应体的类型分别有 Text（文本）、Stream（标准流）、File（文件）。原本是打算用 union 实现这个多类型响应体，由于不是类型安全加上成员隐式构造函数的问题于是放弃了。然后把目光投向了 <a href="https://en.cppreference.com/w/cpp/utility/variant">std::variant</a>，但是 <code>C++17</code> 实现的 std::variant 性能不高，也放弃了。最后只好自己用 struct 手撸了一个<del>类型安全的</del>“联合”。</p><p>剩下的就是 HttpResponse::toRawData()。顾名思义，这个函数是将 HttpResponse 转换为完整的 <code>HTTP</code> 响应（或响应头部），至于实现就用 std::string::append() 按照标准把响应拼接出来就好啦。</p><p>关于 <code>HTTP</code> 响应头可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Response_header">Http Response</a>。</p><h3 id="HttpServices"><a href="#HttpServices" class="headerlink" title="HttpServices"></a>HttpServices</h3><p>HttpServices 是 AbstractServices 的派生类，负责保存不同的业务 handler。在 HttpServices::process() 中会调用业务 handler 和处理 <code>HTTP</code> 业务的相关逻辑。</p><p>首先是业务 handler 的存储。这里用的是两个 Map 嵌套的方式：</p><pre><code class=" mermaid">graph LR    subgraph m_services    Method    subgraph uriHandler        URI --found--&gt; Handler        URI -.not found.-&gt; DefaultHandler    end    Method --&gt; URI    end</code></pre><hr><p>在 HttpServices::process() 中首先会调用 AbstractSocket::read() 接收请求并调用 HttpRequest::parse() 解析请求，接着调用 HttpServices::callHandler() 调用业务处理代码，然后调用 HttpResponse::toRawData() 转换成 <code>HTTP</code> 响应，最后调用 AbstractSocket::write()、AbstractSocket::sendStream()、AbstractSocket::sendFile() 发送响应头和响应体。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="关于-Epoll"><a href="#关于-Epoll" class="headerlink" title="关于 Epoll"></a>关于 Epoll</h3><p>关于 Epoll 的好处<del>人尽皆知</del>，难道它就没有问题吗？当然不是。  </p><p>如果把 AbstractSocket* 放进 epoll_event::data::ptr 里，乍一看很优雅，不用外部维护一个 Map 映射 fd 和 AbstractSocket 了。当 close epoll fd 的时候 epoll_event::data::ptr 指向的内存并不会自动释放，而且我们不能遍历 epoll 内部维护的二叉树释放内存，因此造成内存泄漏。所以必须要存在外部的 holder（在这个项目中是 TimerManager） 控制 AbstractSocket 的生命周期（kqueue 亦是如此）。</p><p>其次，epoll_ctl 是 <code>syscall</code> 且一次只能处理一个描述符。这就意味着当 epoll 面对大量短链接的时候需要频繁陷入内核，浪费大量的 CPU 周期，导致性能下降（kevent 的设计就避免了这个问题）。</p><p>关于 Epoll 设计缺陷更完整的讨论可以看：</p><ul><li><a href="https://www.eet-china.com/mp/a109016.html">盘点LinuxEpoll那些致命弱点</a></li><li><a href="https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/">Epoll is fundamentally broken 1&#x2F;2</a></li><li><a href="https://idea.popcount.org/2017-03-20-epoll-is-fundamentally-broken-22/">Epoll is fundamentally broken 2&#x2F;2</a></li><li><a href="https://zhuanlan.zhihu.com/p/40096515">IO完成端口(IOCP)</a></li></ul><p>更多的并发模型可以看：<a href="https://zhuanlan.zhihu.com/p/364819119">AIO</a>、<a href="https://zhuanlan.zhihu.com/p/62682475">io_uring</a>、<a href="https://zhuanlan.zhihu.com/p/77206570">Go 并发模型</a>。</p><h3 id="亿些教训"><a href="#亿些教训" class="headerlink" title="亿些教训"></a>亿些教训</h3><h4 id="glibc-malloc"><a href="#glibc-malloc" class="headerlink" title="glibc malloc()"></a>glibc malloc()</h4><p>既然用的是 C++ 就肯定少不了喜闻乐见的内存安全问题。当你遇到下面的报错会怎么办呢：</p><blockquote><p>malloc(): unaligned tcache chunk detected</p></blockquote><p>经过一番查找和询问，初步判断是 out of range 或 use after free。</p><p>原因大概知道了，那么如何定位呢？最开始是用 GDB 定位，结果每次都定位到 STL 的一些 construction 里面。我百思不得其解，然后挂上了 <a href="https://zhuanlan.zhihu.com/p/360135083">asan</a>，结果还是令人失望，打印了几行信息之后就没反应了，后面上了 Valgrind 也是一样（毕竟是 asan 的亲爹，当然也可能是我的操作有问题qwq）。进度就这样被搁置了一个星期，我甚至开始想停掉这个项目了，因为一个不能稳定运行的 Server 没有任何意义。最后还是决定去 commit history 碰碰运气（因为之前是没问题的）。</p><p>结果还真找到了，在这个 <a href="https://github.com/ho-229/Network-Learn/commit/7deee7416aa817bbe1bea502b4c400891b28856b">commit</a> 中我忽略了 Timer 被释放之后 AbstractSocket 依旧持有它的指针的问题，导致了 use after free，真的是血的教训…</p><p>从 commit history 找 bug 算是一个比较通用的手段，如果你也遇到了类似的难题不妨试试这个方法。关于 tcache 我的了解不多，下面是一些参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/365170777">从 VNCTF2021-ff 浅析 libc2.32 下 ptmalloc 新增的防护之指针异或加密</a></li><li><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.15_vsyscall_vdso.html">glibc tcache 机制</a></li><li><a href="https://ctf-wiki.org/en/pwn/linux/user-mode/heap/ptmalloc2/implementation/tcache/">tcache - CTF wiki</a></li></ul><h4 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h4><p>你以为到这就完了吗，我在早期还踩过一个大坑，这个坑是关于 <a href="https://zh.cppreference.com/w/cpp/thread/future">std::future</a> 的。</p><p>当时是为了实现 <code>keep alive</code>。实现是在一个循环里调用 accept()，然后调用 <a href="https://zh.cppreference.com/w/cpp/thread/async">std::async()</a> 创建线程处理新链接的所有 <code>HTTP</code> 业务。结果是浏览器并不会复用这个链接反而是关闭它发起一个新链接。最后在求助我师傅 <a href="https://github.com/NiceBlueChai">@NiceBlueChai</a> 的时候，他在 <code>HTTP</code> 业务里输出线程 ID 马上发现了问题：<strong>我只创建了一个线程！而且创建线程和调用 accept 的循环被 std::future 的析构函数阻塞了！</strong> 我做梦也想不到 std::future 析构函数会阻塞。当浏览器发起第二个链接的时候会 Pending（因为服务器的 accept 不会被执行），然后它会主动断开第一个链接并重连。</p><p>在做这个项目的时候踩过的坑远不止一点点，比如说前面提到的 Windows 和 *nix 的 accept 行为不一致…</p><h2 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h2><p>嘛，最后祝大家 Debug 一帆风顺，能够专心做自己想做的事情。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>network</category>
      
      <category>server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>WebServer</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 爬虫</title>
    <link href="/code/Qt/qt-crawler/"/>
    <url>/code/Qt/qt-crawler/</url>
    
    <content type="html"><![CDATA[<ul><li>最近学习了Qt，便想用Qt写个爬虫小demo。<span id="more"></span></li><li>我使用的是Qt 5.12。</li></ul><hr><p>这个爬虫项目的实现一共分三个部分:</p><ol><li><a href="#%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5HTML%E6%BA%90%E7%A0%81%E3%80%82">获取网页HTML源码</a></li><li><a href="#%E8%A7%A3%E6%9E%90HTML%E6%BA%90%E7%A0%81%E5%B9%B6%E6%8F%90%E5%8F%96%E5%87%BA%E6%9C%89%E7%94%A8%E4%BF%A1%E6%81%AF">解析HTML源码并提取出有用信息</a></li><li><a href="#%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87">下载图片</a></li></ol><hr><h3 id="获取网页HTML源码"><a href="#获取网页HTML源码" class="headerlink" title="获取网页HTML源码"></a>获取网页HTML源码</h3><ul><li>先利用 <code>QNetworkRequest</code> 网络请求类构建请求，再利用 <code>QNetworkAccessManager</code> 发送网络请求。当网络请求被回复后，会发出一个 <code>void QNetworkAccessManager::finished(QNetworkReply *reply)</code> 的信号，所以我们把这个信号连接到槽 <code>replyFinished(QNetworkReply *)</code> 来处理这个信号。</li></ul><p>代码如下:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWidget::getMyDiliUserInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> QUrl url)</span></span><span class="hljs-function"></span>&#123;    QNetworkAccessManager *manager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QNetworkAccessManager</span>(<span class="hljs-keyword">this</span>);    <span class="hljs-function">QNetworkRequest <span class="hljs-title">request</span><span class="hljs-params">(url)</span></span>;    <span class="hljs-comment">//设置Headers的信息</span>    request.<span class="hljs-built_in">setRawHeader</span>(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;MyOwnBrowser 1.0&quot;</span>);    <span class="hljs-built_in">connect</span>(manager,<span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">finished</span>(QNetworkReply *)),<span class="hljs-keyword">this</span>,            <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">replyFinished</span>(QNetworkReply *)));    manager-&gt;<span class="hljs-built_in">get</span>(request);  <span class="hljs-comment">// 发送请求</span>&#125;</code></pre></div><hr><h3 id="解析HTML源码并提取出有用信息"><a href="#解析HTML源码并提取出有用信息" class="headerlink" title="解析HTML源码并提取出有用信息"></a>解析HTML源码并提取出有用信息</h3><ul><li>解析HTML最好用的是专门的HTML解析库，由于这个是简易爬虫，所以说我用了Qt5的 <code>QRegularExpression</code> 正则表达式类来解析HTML。</li></ul><p>代码如下:</p><ul><li>获取全部URL</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWidget::getAllUrls</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">QRegularExpression <span class="hljs-title">re</span><span class="hljs-params">(<span class="hljs-string">&quot;(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]&quot;</span>)</span></span>;    QRegularExpressionMatchIterator i=re.<span class="hljs-built_in">globalMatch</span>(HtmlResponse);    <span class="hljs-keyword">while</span> (i.<span class="hljs-built_in">hasNext</span>())        allUrls.<span class="hljs-built_in">push_back</span>(i.<span class="hljs-built_in">next</span>().<span class="hljs-built_in">captured</span>(<span class="hljs-number">0</span>));&#125;</code></pre></div><ul><li>获取图片URL（由于正则表达式只能找出&lt;img&gt;的图片URL，所以可能效果不会很理想）</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWidget::getImageUrls</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">QRegularExpression <span class="hljs-title">re</span><span class="hljs-params">(<span class="hljs-string">&quot;&lt;img.*?src=\&quot;(?&lt;url&gt;(.*?))\&quot;&quot;</span>)</span></span>;    QRegularExpressionMatchIterator i=re.<span class="hljs-built_in">globalMatch</span>(HtmlResponse);    <span class="hljs-keyword">while</span> (i.<span class="hljs-built_in">hasNext</span>())        imageUrls.<span class="hljs-built_in">push_back</span>(i.<span class="hljs-built_in">next</span>().<span class="hljs-built_in">captured</span>(<span class="hljs-string">&quot;url&quot;</span>));&#125;</code></pre></div><hr><h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><ul><li>这里和获取网页HTML源码的步骤差不多，唯一不同的是用 <code>QEventLoop</code> 开启一个局部的事件循环,等待响应结束。当 <code>void QNetworkAccessManager::finished(QNetworkReply *reply)</code> 信号发送给 <code>void QEventLoop::quit()</code> 时退出事件循环。</li></ul><p>代码如下:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWidget::downlodaImage</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;    <span class="hljs-comment">/* 判断路径是否存在 */</span>    <span class="hljs-function">QDir <span class="hljs-title">imageDir</span><span class="hljs-params">(<span class="hljs-string">&quot;./image&quot;</span>)</span></span>;    <span class="hljs-keyword">if</span>(!imageDir.<span class="hljs-built_in">exists</span>())    &#123;        <span class="hljs-keyword">if</span>(!imageDir.<span class="hljs-built_in">mkpath</span>(<span class="hljs-string">&quot;./&quot;</span>))        &#123;            QMessageBox::<span class="hljs-built_in">critical</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;错误&quot;</span>,<span class="hljs-string">&quot;文件夹创建失败&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-comment">/* 遍历 URL 下载图片 */</span>    <span class="hljs-keyword">for</span>(QUrl &amp;imageUrl:imageUrls)    &#123;        QNetworkAccessManager manager;        <span class="hljs-function">QNetworkRequest <span class="hljs-title">request</span><span class="hljs-params">(imageUrl)</span></span>;        QNetworkReply *reply = manager.<span class="hljs-built_in">get</span>(request);    <span class="hljs-comment">// 发送请求</span>        <span class="hljs-comment">//开启一个局部的事件循环,等待响应结束，退出</span>        QEventLoop loop;        <span class="hljs-built_in">connect</span>(reply, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">finished</span>()), &amp;loop, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">quit</span>()));        loop.<span class="hljs-built_in">exec</span>();        <span class="hljs-comment">//判断是否出错,出错则结束</span>        <span class="hljs-keyword">if</span> (reply-&gt;<span class="hljs-built_in">error</span>() != QNetworkReply::NoError)        &#123;            QMessageBox::<span class="hljs-built_in">critical</span>(<span class="hljs-keyword">this</span>,imageUrl.<span class="hljs-built_in">toString</span>(),                <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;下载失败:%1&quot;</span>).<span class="hljs-built_in">arg</span>(reply-&gt;<span class="hljs-built_in">errorString</span>()));            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">//保存文件</span>        <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(QString(<span class="hljs-string">&quot;./image/image_%1.%2&quot;</span>).arg(i)</span></span><span class="hljs-params"><span class="hljs-function">                   .arg(imageUrl.toString().split(<span class="hljs-string">&#x27;.&#x27;</span>).last()))</span></span>;        <span class="hljs-keyword">if</span>(!file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly))        &#123;            QMessageBox::<span class="hljs-built_in">critical</span>(<span class="hljs-keyword">this</span>,file.<span class="hljs-built_in">fileName</span>(),                <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;图片保存失败:%1&quot;</span>).<span class="hljs-built_in">arg</span>(file.<span class="hljs-built_in">errorString</span>()));            <span class="hljs-keyword">continue</span>;        &#125;        file.<span class="hljs-built_in">write</span>(reply-&gt;<span class="hljs-built_in">readAll</span>());        file.<span class="hljs-built_in">close</span>();        reply-&gt;<span class="hljs-built_in">deleteLater</span>();        i++;    &#125;    ui-&gt;DownloadBtn-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;下载图片&quot;</span>);    ui-&gt;DownloadBtn-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">true</span>);    ui-&gt;StartBtn-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">true</span>);    QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示&quot;</span>,<span class="hljs-string">&quot;图片下载完成&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWidget::on_StartBtn_clicked</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(ui-&gt;UrlLineEdit-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">isEmpty</span>())    &#123;        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;错误&quot;</span>,<span class="hljs-string">&quot;请输入URL地址&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getMyDiliUserInfo</span>(ui-&gt;UrlLineEdit-&gt;<span class="hljs-built_in">text</span>());    ui-&gt;StartBtn-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;正在抓取...&quot;</span>);    ui-&gt;StartBtn-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);&#125;</code></pre></div><hr><p>文章到此就结束了，感谢阅读<br>项目源码: <a href="https://github.com/ho229v3666/Qt-Reptile">https://github.com/ho229v3666/Qt-Reptile</a></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/uncategorized/hello-world/"/>
    <url>/uncategorized/hello-world/</url>
    
    <content type="html"><![CDATA[<center>这是我的第一篇博客，纪念这一天 2020/2/27。</center>]]></content>
    
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
